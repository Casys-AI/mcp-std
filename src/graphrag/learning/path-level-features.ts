/**
 * Path-Level Features for PER Training (Story 11.6)
 *
 * Extracts path-level statistics from execution traces for SHGAT training.
 * Path = sequence of nodes executed (tools, capabilities, decisions).
 *
 * Used by trainSHGATOnPathTraces() to enrich training examples with:
 * - Path success rates (historical performance)
 * - Path frequency (popular vs rare paths)
 * - Decision success rates (branch prediction quality)
 *
 * @module graphrag/learning/path-level-features
 */

import type { ExecutionTrace } from "../../capabilities/types.ts";

/**
 * Features computed for a specific execution path
 *
 * These features provide context about how well a path has performed
 * historically, enabling SHGAT to learn path-level patterns.
 */
export interface PathLevelFeatures {
  /** Success rate for this exact path (successes / total executions) */
  pathSuccessRate: number;
  /** Relative frequency of this path (0-1, sums to 1 across all paths) */
  pathFrequency: number;
  /** Average success rate at decision points in this path */
  decisionSuccessRate: number;
  /** Whether this is the most frequently executed path */
  isDominantPath: boolean;
}

/**
 * Extract path-level features from a set of execution traces
 *
 * Groups traces by their execution path and computes aggregate statistics.
 * Path key is generated by joining node IDs with "->".
 *
 * @param traces - Execution traces to analyze
 * @returns Map of path key to features
 *
 * @example
 * ```typescript
 * const traces = await traceStore.getTraces(capabilityId, 100);
 * const features = extractPathLevelFeatures(traces);
 *
 * // features.get("fs:read->json:parse->slack:send")
 * // => { pathSuccessRate: 0.95, pathFrequency: 0.6, ... }
 * ```
 */
export function extractPathLevelFeatures(
  traces: ExecutionTrace[],
): Map<string, PathLevelFeatures> {
  if (traces.length === 0) {
    return new Map();
  }

  // Group traces by path
  const pathStats = new Map<string, { success: number; total: number; traces: ExecutionTrace[] }>();

  for (const trace of traces) {
    const pathKey = (trace.executedPath ?? []).join("->");
    const stats = pathStats.get(pathKey) ?? { success: 0, total: 0, traces: [] };
    stats.total++;
    if (trace.success) stats.success++;
    stats.traces.push(trace);
    pathStats.set(pathKey, stats);
  }

  // Find dominant path (most frequent)
  let dominantPath = "";
  let maxTotal = 0;
  for (const [path, stats] of pathStats) {
    if (stats.total > maxTotal) {
      maxTotal = stats.total;
      dominantPath = path;
    }
  }

  // Calculate features for each path
  const totalTraces = traces.length;
  const features = new Map<string, PathLevelFeatures>();

  for (const [path, stats] of pathStats) {
    features.set(path, {
      pathSuccessRate: stats.total > 0 ? stats.success / stats.total : 0.5,
      pathFrequency: stats.total / totalTraces,
      decisionSuccessRate: calculateDecisionSuccessRate(stats.traces),
      isDominantPath: path === dominantPath,
    });
  }

  return features;
}

/**
 * Calculate average success rate at decision points for a set of traces
 *
 * For each trace, we look at decisions made and whether the trace succeeded.
 * This helps SHGAT learn which branch choices lead to success.
 *
 * @param traces - Traces sharing the same path
 * @returns Average success rate (0-1), defaults to 0.5 if no decisions
 */
function calculateDecisionSuccessRate(traces: ExecutionTrace[]): number {
  if (traces.length === 0) return 0.5;

  let totalDecisions = 0;
  let successfulDecisions = 0;

  for (const trace of traces) {
    const decisionCount = trace.decisions?.length ?? 0;
    if (decisionCount > 0) {
      totalDecisions += decisionCount;
      // If trace succeeded, all its decisions contributed to success
      if (trace.success) {
        successfulDecisions += decisionCount;
      }
    }
  }

  return totalDecisions > 0 ? successfulDecisions / totalDecisions : 0.5;
}

/**
 * Get the path key for a trace
 *
 * Utility function to generate consistent path keys.
 *
 * @param trace - Execution trace
 * @returns Path key string (e.g., "fs:read->json:parse")
 */
export function getPathKey(trace: ExecutionTrace): string {
  return (trace.executedPath ?? []).join("->");
}

/**
 * Get features for a specific trace's path
 *
 * Convenience function to look up features by trace instead of path key.
 *
 * @param trace - The trace to look up
 * @param features - Pre-computed features map
 * @returns Features for this trace's path, or default features if not found
 */
export function getFeaturesForTrace(
  trace: ExecutionTrace,
  features: Map<string, PathLevelFeatures>,
): PathLevelFeatures {
  const pathKey = getPathKey(trace);
  return features.get(pathKey) ?? {
    pathSuccessRate: 0.5,
    pathFrequency: 0,
    decisionSuccessRate: 0.5,
    isDominantPath: false,
  };
}
